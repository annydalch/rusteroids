extern crate sdl2;

use sdl2::rect::{Rect};
use sdl2::event::{Event};
use sdl2::pixels::{Color};
use sdl2::gfx::framerate::FPSManager;
use sdl2::keyboard::Keycode;

mod rocket;
mod globals;
mod asteroid;

use globals::*;
use rocket::RocketShip;
use asteroid::Asteroid;

enum Entity {
    Rocket(RocketShip),
    Asteroid(Asteroid),
}

fn main() {
    let sdl2_context = sdl2::init().unwrap();
    let video_context = sdl2_context.video().unwrap();

    let mut renderer = create_window(&video_context).renderer().build().unwrap();

    let mut entities: Vec<Entity> = Vec::new();

    entities.push(
        Entity::Rocket(RocketShip::new(1, 1, 16, 16))
    );
    entities.push(
        Entity::Asteroid(Asteroid::new(120, 120, 16, 2, 1))
    );

    let mut framerate_controller = FPSManager::new();
    framerate_controller.set_framerate(MAX_FRAMERATE)
        .unwrap();

    'main_loop : loop {
        if !update(&sdl2_context, &mut entities) {
            break 'main_loop;
        } else {
            draw(&mut renderer, &mut entities);
            framerate_controller.delay();
        }
    }
}

fn create_window(video_context: &sdl2::VideoSubsystem) -> sdl2::video::Window {
    video_context.window(WINDOW_TITLE,
                         WINDOW_DIMENSIONS.0,
                         WINDOW_DIMENSIONS.1)
        .position_centered()
        .opengl()
        .build()
        .unwrap()
}

fn update(sdl_context: &sdl2::Sdl, mut entities: &mut Vec<Entity>) -> bool {
    let mut ddx: i32 = 0;
    let mut ddy: i32 = 0;
    let mut event_pump = sdl_context.event_pump().unwrap();
    for event in event_pump.poll_iter() {
        match event {
            Event::Quit{..} => {return false;},
            Event::KeyDown{keycode: Some(Keycode::Escape), ..} => {return false;},
            Event::KeyDown{keycode: Some(Keycode::W), ..} => ddy -= 1,
            Event::KeyDown{keycode: Some(Keycode::S), ..} => ddy += 1,
            Event::KeyDown{keycode: Some(Keycode::A), ..} => ddx -= 1,
            Event::KeyDown{keycode: Some(Keycode::D), ..} => ddy += 1,
            _ => continue,
        }
    }
    for entity in entities.iter() {
        match *entity {
            Entity::Rocket(ref mut rocket) => rocket.update(ddx, ddy),
            Entity::Asteroid(ref mut asteroid) => asteroid.update_position(),
        }
    }
    return true;
}

fn draw_background(mut renderer: &mut sdl2::render::Renderer) {
    renderer.set_draw_color(BACKGROUND_COLOR);
    renderer.fill_rect(None).unwrap();
}

fn draw(mut renderer: &mut sdl2::render::Renderer, mut entities: &mut Vec<Entity>) {
    draw_background(&mut renderer);
    for entity in entities.iter() {
        match *entity {
            Entity::Rocket(ref mut rocket) => rocket.draw(&mut renderer),
            Entity::Asteroid(ref mut asteroid) => asteroid.draw(&mut renderer),
        }
    }
    renderer.present();
}
